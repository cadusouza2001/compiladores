/* Arquivo: FoolParser.cup */
/*
 * Carlos Souza e Murilo Schuck
 * Compiladores - Trabalho GA2
 */

parser code {:
  public static void main(String[] args) throws Exception {
    FoolLexer lexer = new FoolLexer(new java.io.FileReader(args[0]));

    FoolParser parser = new FoolParser(lexer);
    parser.parse();
  }

  public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if (s.value != null) {
                m.append(": value: " + s.value.toString() + " - ");
            }

            if (s.left >= 0) {
                m.append("in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }

        m.append(" : " + message);

        System.err.println("\n" + m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

:};

/* Declaração dos Terminais */
terminal CLASS, INT, BOOL, VOID, IF, ELSE, RETURN, TRUE, FALSE, NOT, AND, OR;
terminal EQ, NEQ, LT, GT, PLUS, TIMES, ASSIGN, DIVIDE, MINUS;
terminal LPAREN, RPAREN, LBRACE, RBRACE, SEMICOLON, COMMA;
terminal IDENTIFIER, INT_CONST;

/* Declaração dos Não Terminais */
non terminal Node program;
non terminal Node class_decl;
non terminal Node method_decl;
non terminal Node attr_decl;
non terminal Node attr_decls;
non terminal Node method_decls;
non terminal Node type;
non terminal Node expr;
non terminal Node command;
non terminal Node command_list;
non terminal Node argument_list;
non terminal Node if_command;
non terminal Node else_command;

/* Precedências */
precedence left ELSE;
precedence left MINUS, PLUS, TIMES, DIVIDE;
precedence left AND, OR;
precedence left EQ, NEQ, LT, GT; 

/* Regras de Produção */
program ::= class_decl:c
    {: RESULT = c; :};                 

class_decl ::= CLASS:cls IDENTIFIER:id LBRACE:lbrace attr_decls:attrs method_decls:meths RBRACE:rbrace
    {: RESULT = new Node(cls.toString(), id.toString(), attrs, meths); :};  

attr_decls ::= /* vazio */
    {: RESULT = new Node("empty_attr_decls"); :}
            | attr_decls:prev attr_decl:attr
    {: RESULT = new Node("attr_decls", prev, attr); :};

method_decls ::= /* vazio */
    {: RESULT = new Node("empty_method_decls"); :}
              | method_decl:meth method_decls:prev
    {: RESULT = new Node("method_decls", meth, prev); :};

attr_decl ::= type:t IDENTIFIER:id SEMICOLON:semi
    {: RESULT = new Node("attr_decl", t, id.toString()); :};

method_decl ::= type:t IDENTIFIER:id LPAREN:lparen argument_list:args RPAREN:rparen LBRACE:lbrace command_list:cmds RBRACE:rbrace
    {: RESULT = new Node("method_decl", t, id.toString(), args, cmds); :};

argument_list ::= /* vazio */
    {: RESULT = new Node("empty_arg_list"); :}
               | argument_list:prev COMMA:comma type:t IDENTIFIER:id
    {: RESULT = new Node("arg_list", prev, t, id.toString()); :}
               | type:t IDENTIFIER:id
    {: RESULT = new Node("arg_list_single", t, id.toString()); :};

command_list ::= /* vazio */
    {: RESULT = new Node("empty_command_list"); :}
              | command_list:prev command:cmd
    {: RESULT = new Node("command_list", prev, cmd); :};

command ::= IDENTIFIER:id ASSIGN:assign expr:e SEMICOLON:semi
    {: RESULT = new Node("assign_command", id.toString(), e); :}
          | if_command:ifc
    {: RESULT = ifc; :}
          | RETURN:returnkw expr:e SEMICOLON:semi
    {: RESULT = new Node("return_command", e); :};

if_command ::= IF:ifkw LPAREN:lparen expr:e RPAREN:rparen command:cmd
    {: RESULT = new Node("if_command", e, cmd); :}
             | IF:ifkw LPAREN:lparen expr:e RPAREN:rparen command:cmd ELSE:elsekw command:elsecmd
    {: RESULT = new Node("if_else_command", e, cmd, elsecmd); :};

expr ::= expr:left PLUS:plus expr:right
    {: RESULT = new Node(plus.toString(), left, right); :}
       | expr:left TIMES:times expr:right
    {: RESULT = new Node(times.toString(), left, right); :}
       | expr:left DIVIDE:divide expr:right
    {: RESULT = new Node(divide.toString(), left, right); :}
       | expr:left MINUS:minus expr:right
    {: RESULT = new Node(minus.toString(), left, right); :}
       | expr:left EQ:eq expr:right
    {: RESULT = new Node(eq.toString(), left, right); :}
       | expr:left NEQ:neq expr:right
    {: RESULT = new Node(neq.toString(), left, right); :}
       | expr:left LT:lt expr:right
    {: RESULT = new Node(lt.toString(), left, right); :}
       | expr:left GT:gt expr:right
    {: RESULT = new Node(gt.toString(), left, right); :}
       | NOT:notkw expr:e
    {: RESULT = new Node(notkw.toString(), e); :}
       | expr:left AND:and expr:right
    {: RESULT = new Node(and.toString(), left, right); :}
       | expr:left OR:or expr:right
    {: RESULT = new Node(or.toString(), left, right); :}
       | IDENTIFIER:id
    {: RESULT = new Node("identifier", id.toString()); :}
       | INT_CONST:num
    {: RESULT = new Node("int_const", num.toString()); :}
       | TRUE:tru
    {: RESULT = new Node("true", tru.toString()); :}
       | FALSE:fal
    {: RESULT = new Node("false", fal.toString()); :};

type ::= INT:intkw
    {: RESULT = new Node("type_int", intkw.toString()); :}
       | BOOL:boolkw
    {: RESULT = new Node("type_bool", boolkw.toString()); :}
       | VOID:voidkw
    {: RESULT = new Node("type_void", voidkw.toString()); :};
