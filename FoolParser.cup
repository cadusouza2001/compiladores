/* Arquivo: FoolParser.cup */
/*
 * Carlos Souza e Murilo Schuck
 * Compiladores - Trabalho GB
 */

parser code {:
  public static void main(String[] args) throws Exception {
    FoolLexer lexer = new FoolLexer(new java.io.FileReader(args[0]));

    FoolParser parser = new FoolParser(lexer);
    Node root = (Node) parser.parse().value;
    root.print();  
}

  public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if (s.value != null) {
                m.append(": value: " + s.value.toString() + " - ");
            }

            if (s.left >= 0) {
                m.append("in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }

        m.append(" : " + message);

        System.err.println("\n" + m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

:};

/* Declaração dos Terminais */
terminal CLASS, INT, BOOL, VOID, IF, ELSE, RETURN, TRUE, FALSE, NOT, AND, OR;
terminal EQ, NEQ, LT, GT, PLUS, TIMES, ASSIGN, DIVIDE, MINUS;
terminal LPAREN, RPAREN, LBRACE, RBRACE, SEMICOLON, COMMA;
terminal IDENTIFIER, INT_CONST;
terminal WHILE;
terminal MAIN;

/* Declaração dos Não Terminais */
non terminal Node program;
non terminal Node class_decl;
non terminal Node method_decl;
non terminal Node attr_decl;
non terminal Node attr_decls;
non terminal Node method_decls;
non terminal Node type;
non terminal Node expr;
non terminal Node command;
non terminal Node command_list;
non terminal Node argument_list;
non terminal Node if_command;
non terminal Node else_command;
non terminal Node while_command;
non terminal Node main_decl;

/* Precedências */
precedence left ELSE;
precedence left MINUS, PLUS, TIMES, DIVIDE;
precedence left AND, OR;
precedence left EQ, NEQ, LT, GT; 

/* Regras de Produção */
program ::= class_decl:c
    {: RESULT = c; :};                 

class_decl ::= CLASS:cls IDENTIFIER:id LBRACE:lbrace attr_decls:attrs method_decls:meths RBRACE:rbrace
    {: RESULT = new Node(cls != null ? cls.toString() : "cls", id != null ? id.toString() : "id", attrs, meths); :};  

attr_decls ::= 
    {: RESULT = new Node("attr_decls"); :}
            | attr_decls:prev attr_decl:attr
    {: prev.addChild(attr); RESULT = prev; :};

method_decls ::= /* vazio */
    {: RESULT = new Node("empty_method_decls"); :}
              | method_decl:meth method_decls:prev
    {: RESULT = new Node("method_decls", meth, prev); :}
              | main_decl:main method_decls:prev
    {: RESULT = new Node("method_decls_with_main", main, prev); :};

main_decl ::= VOID:voidkw MAIN:mainkw LPAREN:lparen RPAREN:rparen LBRACE:lbrace command_list:cmds RBRACE:rbrace
    {: RESULT = new Node("main_decl", cmds); :};

attr_decl ::= type:t IDENTIFIER:id SEMICOLON:semi
    {: RESULT = new Node("attr_decl", t, id != null ? id.toString() : "id"); :};

method_decl ::= type:t IDENTIFIER:id LPAREN:lparen argument_list:args RPAREN:rparen LBRACE:lbrace command_list:cmds RBRACE:rbrace
    {: RESULT = new Node("method_decl", t, id != null ? id.toString() : "id", args, cmds); :};

argument_list ::= /* vazio */
    {: RESULT = new Node("empty_arg_list"); :}
               | argument_list:prev COMMA:comma type:t IDENTIFIER:id
    {: RESULT = new Node("arg_list", prev, t, id != null ? id.toString() : "id"); :}
               | type:t IDENTIFIER:id
    {: RESULT = new Node("arg_list_single", t, id != null ? id.toString() : "id"); :};

command_list ::= /* vazio */
    {: RESULT = new Node("empty_command_list"); :}
              | command_list:prev command:cmd
    {: RESULT = new Node("command_list", prev, cmd); :};

command ::= IDENTIFIER:id ASSIGN:assign expr:e SEMICOLON:semi
    {: RESULT = new Node("assign_command", id != null ? id.toString() : "id", e); :}
          | if_command:ifc
    {: RESULT = ifc; :}
          | RETURN:returnkw expr:e SEMICOLON:semi
    {: RESULT = new Node("return_command", e); :}
          | while_command:whilec
    {: RESULT = whilec; :};

while_command ::= WHILE:whilekw LPAREN:lparen expr:cond RPAREN:rparen command:body
    {: RESULT = new Node("while_command", cond, body); :};

if_command ::= IF:ifkw LPAREN:lparen expr:e RPAREN:rparen command:cmd
    {: RESULT = new Node("if_command", e, cmd); :}
             | IF:ifkw LPAREN:lparen expr:e RPAREN:rparen command:cmd ELSE:elsekw command:elsecmd
        {: 
        Node ifNode = new Node("if_command", e, cmd);
        Node elseNode = new Node("else_command", elsecmd);
        RESULT = new Node("if_else_command", ifNode, elseNode); 
    :};

expr ::= expr:left PLUS:plus expr:right
    {: RESULT = new Node(plus != null ? plus.toString() : "plus", left, right); :}
       | expr:left TIMES:times expr:right
    {: RESULT = new Node(times != null ? times.toString() : "times", left, right); :}
       | expr:left DIVIDE:divide expr:right
    {: RESULT = new Node(divide != null ? divide.toString() : "divide", left, right); :}
       | expr:left MINUS:minus expr:right
    {: RESULT = new Node(minus != null ? minus.toString() : "minus", left, right); :}
       | expr:left EQ:eq expr:right
    {: RESULT = new Node(eq != null ? eq.toString() : "eq", left, right); :}
       | expr:left NEQ:neq expr:right
    {: RESULT = new Node(neq != null ? neq.toString() : "neq", left, right); :}
       | expr:left LT:lt expr:right
    {: RESULT = new Node(lt != null ? lt.toString() : "lt", left, right); :}
       | expr:left GT:gt expr:right
    {: RESULT = new Node(gt != null ? gt.toString() : "gt", left, right); :}
       | NOT:notkw expr:e
    {: RESULT = new Node(notkw != null ? notkw.toString() : "notkw", e); :}
       | expr:left AND:and expr:right
    {: RESULT = new Node(and != null ? and.toString() : "and", left, right); :}
       | expr:left OR:or expr:right
    {: RESULT = new Node(or != null ? or.toString() : "or", left, right); :}
       | IDENTIFIER:id
    {: RESULT = new Node("identifier"); :}
       | INT_CONST:num
    {: RESULT = new Node("int_const"); :}
       | TRUE:tru
    {: RESULT = new Node("true"); :}
       | FALSE:fal
    {: RESULT = new Node("false"); :};

type ::= INT:intkw
        {: RESULT = new Node("type_int"); :}
       | BOOL:boolkw
    {: RESULT = new Node("type_bool"); :}
       | VOID:voidkw
    {: RESULT = new Node("type_void"); :};