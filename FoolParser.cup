/* Arquivo: FoolParser.cup */
/*
 * Carlos Souza e Murilo Schuck
 * Compiladores - Trabalho GA2
 */

import java_cup.runtime.*;

parser code {:
  public static void main(String[] args) throws Exception {
    FoolLexer lexer = new FoolLexer(new java.io.FileReader(args[0]));

    FoolParser parser = new FoolParser(lexer);
    parser.parse();
  }

  public boolean result = true;

  public void report_fatal_error(String message, Object info) throws java.lang.Exception {
    done_parsing();
    System.out.println("report_fatal_error");
    report_error();
  }

  public void syntax_error(Symbol cur_token) {
    System.out.println("syntax_error");
    report_error();
  }

  public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
    System.out.println("unrecovered_syntax_error");
    report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
  }

  public void report_error() {
    System.out.println("report_error");
    result = false;
  }
:};

init with {: result = true; :};

/* Declaração dos Terminais */
terminal CLASS, INT, BOOL, VOID, IF, ELSE, RETURN, TRUE, FALSE, NOT, AND, OR;
terminal EQ, NEQ, LT, GT, PLUS, TIMES, ASSIGN;
terminal LPAREN, RPAREN, LBRACE, RBRACE, SEMICOLON, COMMA;
terminal IDENTIFIER, INT_CONST;

/* Declaração dos Não Terminais */
non terminal Node program;
non terminal Node class_decl;
non terminal Node method_decl;
non terminal Node attr_decl;
non terminal Node attr_decls;
non terminal Node method_decls;
non terminal Node type;
non terminal Node expr;
non terminal Node command;
non terminal Node command_list;
non terminal Node argument_list;
non terminal Node if_command;
non terminal Node else_command;

/* Precedências */
precedence left ELSE;
precedence left PLUS, TIMES;
precedence left AND, OR;
precedence left EQ, NEQ, LT, GT;

/* Regras de Produção */
program ::= class_decl:cd
          {: RESULT = cd; :};

class_decl ::= CLASS IDENTIFIER:id LBRACE attr_decls:ad method_decls:md RBRACE
             {: RESULT = new Node(id.toString(), "CLASS", false, ad, md); :};

attr_decls ::= /* vazio */
             {: RESULT = null; :}
             | attr_decls:ads attr_decl:ad
             {: RESULT = new Node("", "ATTR_DECLS", false, ads, ad); :};

method_decls ::= /* vazio */
               {: RESULT = null; :}
               | method_decl:md method_decls:mds
               {: RESULT = new Node("", "METHOD_DECLS", false, md, mds); :};

attr_decl ::= type:t IDENTIFIER:id SEMICOLON
            {: RESULT = new Node(id.toString(), "ATTR_DECL", false, t); :};

method_decl ::= type:t IDENTIFIER:id LPAREN argument_list:al RPAREN LBRACE command_list:cl RBRACE
              {: RESULT = new Node(id.toString(), "METHOD_DECL", false, t, al, cl); :};

argument_list ::= /* vazio */
                {: RESULT = null; :}
                | argument_list:als COMMA type:t IDENTIFIER:id
                {: RESULT = new Node(id.toString(), "ARG_LIST", false, als, t); :}
                | type:t IDENTIFIER:id
                {: RESULT = new Node(id.toString(), "ARG_LIST", false, t); :};

command_list ::= /* vazio */
               {: RESULT = null; :}
               | command_list:cls command:c
               {: RESULT = new Node("", "COMMAND_LIST", false, cls, c); :};

command ::= IDENTIFIER:id ASSIGN expr:e SEMICOLON
          {: RESULT = new Node(id.toString(), "ASSIGN", false, e); :}
          | if_command:ic
          {: RESULT = ic; :}
          | RETURN expr:e SEMICOLON
          {: RESULT = new Node("", "RETURN", false, e); :};

if_command ::= IF LPAREN expr:e RPAREN command:c
             {: RESULT = new Node("", "IF", false, e, c); :}
             | IF LPAREN expr:e RPAREN command:c ELSE command:ec
             {: RESULT = new Node("", "IF_ELSE", false, e, c, ec); :};

else_command ::= /* vazio */
               {: RESULT = null; :}
               | ELSE command:c
               {: RESULT = c; :};

expr ::= expr:e1 PLUS expr:e2
       {: RESULT = new Node("", "PLUS", false, e1, e2); :}
       | expr:e1 TIMES expr:e2
       {: RESULT = new Node("", "TIMES", false, e1, e2); :}
       | expr:e1 EQ expr:e2
       {: RESULT = new Node("", "EQ", false, e1, e2); :}
       | expr:e1 NEQ expr:e2
       {: RESULT = new Node("", "NEQ", false, e1, e2); :}
       | expr:e1 LT expr:e2
       {: RESULT = new Node("", "LT", false, e1, e2); :}
       | expr:e1 GT expr:e2
       {: RESULT = new Node("", "GT", false, e1, e2); :}
       | NOT expr:e
       {: RESULT = new Node("", "NOT", false, e); :}
       | expr:e1 AND expr:e2
       {: RESULT = new Node("", "AND", false, e1, e2); :}
       | expr:e1 OR expr:e2
       {: RESULT = new Node("", "OR", false, e1, e2); :}
       | IDENTIFIER:id
       {: RESULT = new Node(id.toString(), "IDENTIFIER", false); :}
       | INT_CONST:ic
       {: RESULT = new Node(ic.toString(), "INT_CONST", false); :}
       | TRUE
       {: RESULT = new Node("TRUE", "BOOL_CONST", false); :}
       | FALSE
       {: RESULT = new Node("FALSE", "BOOL_CONST", false); :};

type ::= INT
       {: RESULT = new Node("INT", "TYPE", false); :}
       | BOOL
       {: RESULT = new Node("BOOL", "TYPE", false); :}
       | VOID
       {: RESULT = new Node("VOID", "TYPE", false); :};